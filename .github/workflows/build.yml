name: 外科手术修复版-生成EXE
on: workflow_dispatch

jobs:
  build-windows:
    runs-on: windows-latest
    
    steps:
    - uses: actions/checkout@v3
      with:
        submodules: recursive

    - name: 1. 准备环境 (vcpkg)
      run: |
        git clone https://github.com/Microsoft/vcpkg.git
        .\vcpkg\bootstrap-vcpkg.bat

    - name: 2. 安装依赖 (ImGui, GLFW, Boost)
      run: .\vcpkg\vcpkg install glfw3:x64-windows imgui[core,glfw-binding,opengl3-binding]:x64-windows boost-asio boost-system boost-thread boost-date-time boost-regex:x64-windows

    - name: 3. 现场手搓 Nanoid
      shell: powershell
      run: |
        New-Item -ItemType Directory -Force -Path "nanoid_root\nanoid"
        $code = @"
        #pragma once
        #include <string>
        #include <random>
        namespace nanoid {
            static const std::string _default_dict = "_-0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
            inline std::string generate(int size = 21) {
                if (size <= 0) return "";
                std::random_device rd;
                std::mt19937 gen(rd());
                std::uniform_int_distribution<> dis(0, 63);
                std::string res;
                res.reserve(size);
                for (int i = 0; i < size; ++i) { res += _default_dict[dis(gen)]; }
                return res;
            }
        }
        "@
        Set-Content -Path "nanoid_root\nanoid\nanoid.h" -Value $code

    - name: 4. 部署 Steam SDK 并 修复 CMakeLists.txt
      shell: powershell
      run: |
        # --- 下载 SDK ---
        $url = "https://github.com/bwwq/test/raw/main/steamworks_sdk_163.zip"
        Invoke-WebRequest -Uri $url -OutFile "sdk.zip" -ErrorAction Stop
        if ((Get-Item "sdk.zip").Length -lt 1000) { throw "SDK file invalid" }
        
        # 解压
        Expand-Archive -Path "sdk.zip" -DestinationPath "temp_sdk" -Force
        
        # --- 还原官方结构 (Project Root/steamworks) ---
        # 找到包含 'public' 文件夹的那一层，把它重命名为 steamworks 放在根目录
        $root = Get-ChildItem -Path "temp_sdk" -Recurse -Filter "public" | Select-Object -First 1
        Move-Item -Path $root.Parent.FullName -Destination ".\steamworks" -Force
        
        # --- 这里的关键：把 steam_api64.dll 复制出来备用 ---
        New-Item -ItemType Directory -Force -Path "build\Release"
        $dll = Get-ChildItem -Path "steamworks" -Recurse -Filter "steam_api64.dll" | Select-Object -First 1
        Copy-Item -Path $dll.FullName -Destination "build\Release" -Force

        # --- 【外科手术】修改 CMakeLists.txt ---
        Write-Output "Patching CMakeLists.txt to remove macOS garbage..."
        
        # 读取文件
        $cmake = Get-Content "CMakeLists.txt"
        
        # 过滤掉包含 .dylib 或 osx 的行 (这些行会导致 Windows 链接失败)
        $clean_cmake = $cmake | Where-Object { $_ -notmatch "\.dylib" -and $_ -notmatch "/osx/" }
        
        # 写回文件
        $clean_cmake | Set-Content "CMakeLists.txt"
        
        Write-Output "Patch applied. CMakeLists.txt is now Windows-clean."

    - name: 5. 编译项目
      run: |
        New-Item -ItemType Directory -Force -Path "build"
        cd build
        # 此时有了 steamworks 文件夹，原项目的 include 路径应该能生效
        # 但为了保险，我们依然强制加上 /I 参数指向我们整理好的路径
        cmd /c "cmake .. -DCMAKE_TOOLCHAIN_FILE=../vcpkg/scripts/buildsystems/vcpkg.cmake -DVCPKG_TARGET_TRIPLET=x64-windows -DCMAKE_CXX_FLAGS=""/I ../vcpkg/installed/x64-windows/include /I ../steamworks/public /I ../nanoid_root /EHsc"""
        cmd /c "cmake --build . --config Release"

    - name: 6. 上传成品
      uses: actions/upload-artifact@v4
      with:
        name: ConnectTool-Windows
        path: build/Release/*
